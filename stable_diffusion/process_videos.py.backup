#!/usr/bin/env python3
"""
Stable Diffusion 视频批量编辑
添加雨雾效果和遮挡效果
"""

import os
import glob
import subprocess
from pathlib import Path
import torch
from diffusers import StableDiffusionImg2ImgPipeline
from PIL import Image
from tqdm import tqdm
import json
import sys

# ==================== 配置区域 ====================
WORK_DIR = "/root/autodl-tmp/sida"
SD_DIR = f"{WORK_DIR}/stable_diffusion"
MODEL_DIR = f"{SD_DIR}/models"
VIDEO_INPUT_DIR = f"{WORK_DIR}/urban_videos/original"
VIDEO_OUTPUT_DIR = f"{WORK_DIR}/urban_videos/processed"
TEMP_DIR = f"{SD_DIR}/temp"

# Prompt配置
RAIN_FOG_PROMPT = "heavy rain and thick fog, rainy weather, water droplets on camera lens, misty atmosphere, wet road surfaces, reduced visibility, stormy conditions"

OCCLUSION_PROMPT = "random objects and obstacles partially blocking the view, obscured perspective, construction barriers in foreground, obstructed street view"

NEGATIVE_PROMPT = "blurry, distorted, low quality, bad anatomy, deformed, ugly"

# 参数配置
FPS = 8
STRENGTH = 0.35
GUIDANCE_SCALE = 7.5
NUM_INFERENCE_STEPS = 30

# ==================== 核心函数 ====================

def load_model():
    """加载Stable Diffusion模型到指定目录"""
    print("\n" + "="*70)
    print("正在加载 Stable Diffusion 模型...")
    print("="*70)
    
    # 确保模型目录存在
    os.makedirs(MODEL_DIR, exist_ok=True)
    
    # 设置缓存目录
    os.environ['HF_HOME'] = MODEL_DIR
    os.environ['TRANSFORMERS_CACHE'] = MODEL_DIR
    
    model_path = os.path.join(MODEL_DIR, "stable-diffusion-v1-5")
    
    # 检查模型是否已下载
    if os.path.exists(model_path) and os.path.isdir(model_path):
        print(f"✓ 从本地加载模型: {model_path}")
        try:
            pipe = StableDiffusionImg2ImgPipeline.from_pretrained(
                model_path,
                torch_dtype=torch.float16,
                safety_checker=None,
                requires_safety_checker=False,
                local_files_only=True
            )
        except Exception as e:
            print(f"本地加载失败: {e}")
            print("将重新下载模型...")
            pipe = download_and_load_model(model_path)
    else:
        print(f"首次运行，下载模型到: {model_path}")
        print("（约4GB，需要5-10分钟，请耐心等待）\n")
        pipe = download_and_load_model(model_path)
    
    pipe = pipe.to("cuda")
    pipe.enable_attention_slicing()
    pipe.enable_vae_slicing()
    
    print("✓ 模型加载完成")
    print(f"✓ 模型位置: {model_path}")
    print("="*70 + "\n")
    return pipe

def download_and_load_model(save_path):
    """下载并保存模型"""
    pipe = StableDiffusionImg2ImgPipeline.from_pretrained(
        "runwayml/stable-diffusion-v1-5",
        torch_dtype=torch.float16,
        safety_checker=None,
        requires_safety_checker=False,
        cache_dir=MODEL_DIR
    )
    
    # 保存模型到本地
    print(f"\n保存模型到: {save_path}")
    pipe.save_pretrained(save_path)
    print("✓ 模型保存完成\n")
    
    return pipe

def extract_frames(video_path, output_dir, fps=8):
    """提取视频帧"""
    os.makedirs(output_dir, exist_ok=True)
    
    probe_cmd = [
        'ffprobe', '-v', 'error',
        '-select_streams', 'v:0',
        '-show_entries', 'stream=width,height',
        '-of', 'csv=p=0',
        video_path
    ]
    
    try:
        result = subprocess.run(probe_cmd, capture_output=True, text=True, check=True)
        width, height = map(int, result.stdout.strip().split(','))
        
        if width > height:
            scale = f"512:-1"
        else:
            scale = f"-1:512"
        
        cmd = [
            'ffmpeg', '-i', video_path,
            '-vf', f'fps={fps},scale={scale}',
            '-q:v', '2',
            f'{output_dir}/frame_%06d.png',
            '-y'
        ]
        
        subprocess.run(cmd, check=True, capture_output=True, stderr=subprocess.DEVNULL)
        frames = sorted(glob.glob(f'{output_dir}/frame_*.png'))
        return frames, (width, height)
    
    except Exception as e:
        print(f"      提取帧失败: {e}")
        return [], None

def process_frame(pipe, frame_path, prompt, output_path):
    """处理单帧"""
    try:
        image = Image.open(frame_path).convert('RGB')
        
        result = pipe(
            prompt=prompt,
            negative_prompt=NEGATIVE_PROMPT,
            image=image,
            strength=STRENGTH,
            guidance_scale=GUIDANCE_SCALE,
            num_inference_steps=NUM_INFERENCE_STEPS
        ).images[0]
        
        result.save(output_path)
        return True
    
    except Exception as e:
        return False

def frames_to_video(frames_dir, output_path, fps=8, original_size=None):
    """合成视频"""
    pattern = f"{frames_dir}/frame_%06d.png"
    
    cmd = [
        'ffmpeg',
        '-framerate', str(fps),
        '-i', pattern,
        '-c:v', 'libx264',
        '-preset', 'medium',
        '-crf', '18',
        '-pix_fmt', 'yuv420p'
    ]
    
    if original_size:
        width, height = original_size
        cmd.extend(['-vf', f'scale={width}:{height}'])
    
    cmd.extend([output_path, '-y'])
    
    try:
        subprocess.run(cmd, check=True, capture_output=True, stderr=subprocess.DEVNULL)
        return True
    except:
        return False

def process_video(pipe, video_path, effect_type):
    """处理单个视频"""
    video_name = Path(video_path).stem
    suffix = f"_{effect_type}"
    output_path = os.path.join(VIDEO_OUTPUT_DIR, f"{video_name}{suffix}.mp4")
    
    if os.path.exists(output_path):
        print(f"    已存在，跳过: {video_name}{suffix}")
        return True
    
    print(f"    处理: {video_name} -> {effect_type}")
    
    temp_video_dir = os.path.join(TEMP_DIR, f"{video_name}_{effect_type}")
    input_frames_dir = os.path.join(temp_video_dir, "input")
    output_frames_dir = os.path.join(temp_video_dir, "output")
    os.makedirs(input_frames_dir, exist_ok=True)
    os.makedirs(output_frames_dir, exist_ok=True)
    
    print(f"       [1/3] 提取视频帧...")
    frames, original_size = extract_frames(video_path, input_frames_dir, fps=FPS)
    
    if not frames:
        print(f"    提取帧失败")
        return False
    
    print(f"       完成，共 {len(frames)} 帧")
    
    print(f"       [2/3] 处理每一帧...")
    prompt = RAIN_FOG_PROMPT if effect_type == 'rain_fog' else OCCLUSION_PROMPT
    
    success_count = 0
    with tqdm(total=len(frames), desc="       进度", ncols=80) as pbar:
        for frame_path in frames:
            frame_name = Path(frame_path).name
            output_frame_path = os.path.join(output_frames_dir, frame_name)
            
            if process_frame(pipe, frame_path, prompt, output_frame_path):
                success_count += 1
            
            pbar.update(1)
    
    print(f"       成功 {success_count}/{len(frames)} 帧")
    
    if success_count > 0:
        print(f"       [3/3] 合成视频...")
        if frames_to_video(output_frames_dir, output_path, fps=FPS, original_size=original_size):
            print(f"    完成: {Path(output_path).name}\n")
            subprocess.run(['rm', '-rf', temp_video_dir], check=False)
            return True
        else:
            print(f"    合成视频失败\n")
            return False
    else:
        print(f"    没有成功处理的帧\n")
        return False

# ==================== 主程序 ====================

def main():
    print("\n" + "="*70)
    print("Stable Diffusion 视频批量编辑")
    print("="*70 + "\n")
    
    # 创建目录
    os.makedirs(VIDEO_OUTPUT_DIR, exist_ok=True)
    os.makedirs(TEMP_DIR, exist_ok=True)
    
    # 检查输入目录
    if not os.path.exists(VIDEO_INPUT_DIR):
        print(f"输入目录不存在: {VIDEO_INPUT_DIR}")
        sys.exit(1)
    
    # 获取视频列表
    video_files = []
    for ext in ['*.mp4', '*.avi', '*.mov', '*.mkv']:
        video_files.extend(glob.glob(os.path.join(VIDEO_INPUT_DIR, ext)))
    
    if not video_files:
        print(f"未找到视频文件: {VIDEO_INPUT_DIR}")
        print(f"\n请将视频文件放入该目录后重新运行")
        sys.exit(1)
    
    print(f"找到 {len(video_files)} 个视频")
    print(f"输入: {VIDEO_INPUT_DIR}")
    print(f"输出: {VIDEO_OUTPUT_DIR}\n")
    
    # 加载模型
    pipe = load_model()
    
    # 加载进度
    progress_file = os.path.join(TEMP_DIR, 'progress.json')
    if os.path.exists(progress_file):
        with open(progress_file, 'r') as f:
            completed = json.load(f)
    else:
        completed = []
    
    # 处理视频
    for idx, video_path in enumerate(video_files, 1):
        video_name = Path(video_path).stem
        
        print(f"{'='*70}")
        print(f"[{idx}/{len(video_files)}] {video_name}")
        print(f"{'='*70}")
        
        # 处理雨雾效果
        task_rain = f"{video_name}_rain_fog"
        if task_rain not in completed:
            if process_video(pipe, video_path, 'rain_fog'):
                completed.append(task_rain)
                with open(progress_file, 'w') as f:
                    json.dump(completed, f)
        else:
            print(f"    跳过: rain_fog (已完成)")
        
        # 处理遮挡效果
        task_occ = f"{video_name}_occlusion"
        if task_occ not in completed:
            if process_video(pipe, video_path, 'occlusion'):
                completed.append(task_occ)
                with open(progress_file, 'w') as f:
                    json.dump(completed, f)
        else:
            print(f"    跳过: occlusion (已完成)")
    
    print(f"\n{'='*70}")
    print(f"全部完成")
    print(f"成功: {len(completed)}/{len(video_files)*2}")
    print(f"输出: {VIDEO_OUTPUT_DIR}")
    print(f"{'='*70}\n")

if __name__ == "__main__":
    main()
